---
title: "Serverless Static Websites in AWS — a 2020 Guide
"
date: 2020-05-22T22:14:27-05:00
draft: true
---

This is a writeup on how I build this site. I wanted a highly reliable, cost effective and low maintenance way of getting my content out. After checking out options like GitHub pages, Netlify etc, I decided to settle for AWS as my preferred way. Although GitHub pages initially seemed to be what I was looking for, they had a very opinionated branching strategy for personal sites (content source code cannot be in master branch) and the GitHub actions was buggy and not production worthy. After losing patience with GitHub pages, I settled down with AWS which I was familiar with and had past success on. The ability to have control over a customized disaster recovery, better performance via CloudFront CDN and complete serverless deployment also helped the case of AWS.

This guide shows how to do a serverless static website deployment in AWS using [AWS Serverless Application Model](https://aws.amazon.com/serverless/sam/) and how to create an automated continuos integration and continuos delivery pipeline. We will use Hugo to create a static site, but the same can be extended to Angular, React, GatsbyJS or any other static sites. We will be leveraging AWS SAM to deploy this static website in a serverless manner. Static assets will be stored in AWS S3 and content served by CloudFront's worldwide edge servers providing blazing fast content delivery to consumers. The source code for the site will be stored in GitHub and we will use AWS Code Builder to automatically build and deploy the site whenever a change is pushed to Github.

Let's get introduced to few technologies that we will use in this guide.

### Hugo

[Hugo](https://gohugo.io/) is a static website generator. You can write your content in Markdown format and hugo converts them into HTML format and applies a theme while doing it. There are no databases to maintain and all content are served as pre-created HTML files. The resultant HTML files can be served using any httpd server like apache or nginx with minimal configuration. But in our case, we will store the HTML files in S3 and serve the content via CloudFront servers.

### AWS SAM

[AWS SAM](https://aws.amazon.com/serverless/sam/) is framework for building serverless applications leveraging multiple AWS technologies. In its heart, it consist of a infrastructure configuration file (can be represented in JSON or YAML formats) which is a superset of AWS CloudFormation syntax and a command line interface (sam-cli). SAM provides an easy way to declare serverless compute like Lambda functions, AppSync, S3, DynamoDB, API gateway etc and deploy them.

### AWS S3

[AWS Simple Storage Service](https://aws.amazon.com/s3/) is an object storage service. We will be using S3 to store HTML files generated by Hugo. S3 supports static site hosting out of box, however this requires that we make the bucket publicly accessible. This also makes it difficult to add multi-region disaster recovery for our sites. Instead, we will lock down the bucket tightly and give permission to CloudFront alone to access the contents of this bucket.

### AWS CloudFront

[AWS CloudFront](https://aws.amazon.com/cloudfront/) is a Content Delivery Network (CDN) that delivers content to customers globally with low latency and high transfer speeds. In our case, CloudFront will act as the web server serving HTML pages, CSS, JS files, Images etc. CloudFront fetches data from S3 and caches at edge nodes that are closer to customers across the globe.

### AWS CodeBuild

[AWS CodeBuild](https://aws.amazon.com/codebuild/) is part of AWS Developer tools. In function, it is equivalent to a Serverless Jenkins server. If listens to changes in your code repository (GitHub in our case) and builds the code and generates the HTML artifacts. It also pushes the HTML pages to our destination S3 buckets. This decouples the content writers from the whole AWS ecosystem. Content writes can push updated Markdown files to GitHub and CodeBuild works behind the scene to automatically build the HTML pages using Hugo and publishing it to production.

### Route53 & ACM

[Route53](https://aws.amazon.com/route53/) is a highly available and scalable DNS service from AWS. We will be using a custom domain for our static site and we will onboard that domain as a zone in Route53. We will not automate this step since this is a one time thing and also needs manual verification to prove that you own the domain. And the details of how to onboard your domain name to Route53 is outside the scope of this guide.

[AWS Certificate Manager](https://aws.amazon.com/certificate-manager/) will help us create a free SSL certificate so that we can serve our site over HTTPS.

## Design

This is the overall architecture of our final design.

![Architecture diagram](./images/static-website-aws-architecture.svg)

### Content Generation

Content authors generate content in Markdown format and commits this into Github. The GitHub hooks that we have setup as part of initial setup gets triggered with each code push and sets up a new build in motion in AWS CodeBuild. A build in CodeBuild has four main steps:

1. Checkout the source code from Git
1. Setup the build environment. In our case this will be a custom Docker container that has Hugo and AWS CLI binaries installed
1. Execute the hugo build commands
1. Push the generated artifacts to our target S3 directory
1. Optional: invalidate CloudFront so that it refreshes its cache with fresh contents in S3

### Content Consumption

When customer visits the site, the browser first queries Route53 DNS service which will resole to a CloudFront edge node that is closer to their physical location. The CloudFront server uses S3 as the source.

## Implementation

Follow these steps to setup your static site.

### Prerequisites

1. You have an AWS account. If not [create one](https://aws.amazon.com/account/)
1. [Install AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html) and [configure it](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html#cli-quick-configuration)
1. [Install SAM CLI](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html)

### Step 1: Setup Route53

Follow the steps in [this page](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/MigratingDNS.html) if you already have a domain and need to transfer it to AWS.

Follow instructions in [this page](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/domain-register.html) if you need to register a domain from scratch.

Either way by the end, you need to have a hosted zone setup at the end.

### Step 2: Setup ACM

Follow [steps here](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) to request a public certificate for your domain. You will need to validate that you own the domains by either DNS validation or email validation.

### Step 3: Create SAM S3 Bucket

It is important to understand that we will be dealing with two S3 buckets and not just one. The first bucket that we will be creating here is for SAM to store its state information. We will be creating this bucket manually since this is a one time thing. The main S3 bucket where the HTML content will reside will be created via the SAM template and not manually.

Run the following command from your terminal:

```
$ aws s3 mb s3://MYSITE.COM.sam --region us-east-1
```

Replace MYSITE.COM with your site name, but add `.sam` to the end to denote that this will be used by SAM alone.

### Step 4: Setup SAM template

Save the following content as `template.yaml`:

```
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: >
  MYSITE.COM website

Resources:
  CloudFrontOriginAccessIdentity:
    Type: "AWS::CloudFront::CloudFrontOriginAccessIdentity"
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: "MYSITE.COM website"

  CloudfrontDistribution:
    Type: "AWS::CloudFront::Distribution"
    Properties:
      DistributionConfig:
        Comment: "MYSITE.COM website"
        DefaultRootObject: "index.html"
        Aliases: ["MYSITE.COM"]
        ViewerCertificate:
          AcmCertificateArn: "YOUR_ACM_CERT_ARN"
          SslSupportMethod: sni-only
        Enabled: true
        HttpVersion: http2
        # List of origins that Cloudfront will connect to
        Origins:
          - Id: s3-website
            DomainName: !GetAtt S3Bucket.DomainName
            S3OriginConfig:
              # Restricting Bucket access through an origin access identity
              OriginAccessIdentity:
                Fn::Sub: "origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}"
        DefaultCacheBehavior:
          Compress: "true"
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          ForwardedValues:
            QueryString: false
          TargetOriginId: s3-website
          ViewerProtocolPolicy: redirect-to-https

  S3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      # Change bucket name to reflect your website
      BucketName: MYSITE.COM

  S3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref S3Bucket
      PolicyDocument:
        # Restricting access to cloudfront only.
        Statement:
          - Effect: Allow
            Action: "s3:GetObject"
            Resource:
              - !Sub "arn:aws:s3:::${S3Bucket}/*"
            Principal:
              AWS: !Sub "arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${CloudFrontOriginAccessIdentity}"

```

Replace instances of `MYSITE.COM` with your site domain name. Replace `YOUR_ACM_CERT_ARN` with the ARN of the ACM cert that you created in Step 2.

### Step 5: Setup SAM config

Save the following content as `samconfig.toml` in the same directory as `template.yaml`:

```
version = 0.1
[default]
[default.deploy]
[default.deploy.parameters]
stack_name = "MY-SITE-COM-site"
s3_bucket = "MYSITE.COM.sam"
s3_prefix = "MY-SITE-COM"
region = "us-east-1"
confirm_changeset = false
capabilities = "CAPABILITY_IAM"

```

Remember to update MY-SITE-COM to reflect your actual site name. `s3_bucket` value should be the name of the SAM S3 bucket we created in Step 3.

### Step 6: Deploy the Infrastructure

Launch a terminal, `cd` to the directory where you have `template.yaml` and run the following command:

```
sam validate && sam build && sam deploy
```

This will create the necessary IAM roles, the CloudFront resources and distribution and the S3 bucket. The CloudFront distribution will be configured to use the new S3 bucket as its origin.

### Step 7: Create Route53 Record Sets

In [Route53 console](https://console.aws.amazon.com/route53), select the hosted zone of your domain. Then create two Record Sets – one of type `A` and another of type `AAAA`.

Name: `www`
Alias: `Yes`
Alias Target: `Select the cloudfront distribution name`
Routing Policy: `Simple`

### Step 8: Validate

Create an index.html file in your MYSITE.COM bucket with the following content:

```
<html>
    <body>
        <h1>Hello, World!</h1>
    </body>
</html>
```

If all goes right, you should see `Hello, World!` in your browser if you navigate to www.MYSITE.com

## CICD Pipeline

Now that we have a working site, let's build an automatic CICD pipeline that will publish the site when ever new content is pushed to GitHub
